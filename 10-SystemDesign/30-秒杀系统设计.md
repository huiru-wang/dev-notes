---
title: 秒杀系统设计
category: DistSystem
tags:
  - systemDesign
publishedAt: 2023-01-15
description: 介绍IP、TCP、UDP、HTTP(S)、RPC、WebSocket等
---


# 1. 关键挑战

1. 瞬时高并发：秒杀开始瞬间流量可能达到百万级请求。
2. 资源竞争：库存有限，需防止超卖（超库存售卖）。
3. 系统稳定性：避免因高并发导致服务雪崩、数据库崩溃。
4. 数据一致性：保证库存扣减、订单生成的强一致性。
5. 恶意请求：防御黄牛、机器人刷单等攻击。


# 2. 关键技术设计点

## 2.1 流量控制

1. 用户级最大TPS限流；如单用户最大5次/秒；
2. 无效流量拦截，尽量减少执行库存逻辑的流量，降低服务端、缓存服务的压力。比如：用户的秒杀请求在执行前，先争强token，获取token成功的请求才执行后续的秒杀逻辑，token的数量可以大于库存量，但远小于总秒杀用户数；


## 2.2 库存管理
1. 库存预热：预热库存，提前加载到缓存中，减少数据库压力。
2. 分布式锁实现库存扣减逻辑；需保证库存扣减的原子性：
- 
1. 秒杀压力过大，锁竞争严重，并发性能不足，还可以考虑分段锁设计；将要秒杀的商品分片，降低单个锁的竞争，提高并发度；



# 3. 优化点

## 3.1 秒杀过程CPU升高

原因：
- 高并发请求处理，大量请求涌入，服务线程满载，线程的在库存扣减过程中的锁争抢、阻塞、上下文切换等都会大量消耗CPU资源；
- JVM的垃圾回收机制，频繁的young gc，甚至Full GC都会导致STW，进一步加剧CPU的升高；

方案：
- 降低单锁竞争，使用分段锁；
- 无锁化库存扣减，使用Lua脚本实现：
    ```lua
    -- Redis原子扣减库存脚本
    local stock = tonumber(redis.call('GET', KEYS[1]))
    if stock > 0 then
        redis.call('DECR', KEYS[1])
        return 1
    else
        return 0
    end
    ```
- JIT优化预热代码；预防流量突发；
- 线程优化：
    - 线程池大小：根据业务场景调整线程池大小，避免线程创建和销毁带来的性能消耗；
    - 使用响应式的非阻塞IO模型（Spring WebFlux）而非阻塞IO模型（Spring MVC/Servlet）；
    - WebFlux使用事件循环机制，而非servlet的线程池模型，使用更少的线程数，更适合高并发场景，资源利用率更高；

